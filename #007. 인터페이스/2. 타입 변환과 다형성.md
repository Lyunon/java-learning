# 타입 변환과 다형성
프로그램을 개발할 때 인터페이스를 사용해서 메소드를 호출하도록 코딩했다면, 구현 객체를 매우 손쉽고 빠르게 교체할 수 있다. 프로그램 소스 코드는 변함이 없는데, 구현 객체를 교체함으로써 프로그램의 실행결과가 다양해진다. 이것이 **인터페이스의 다형성**이다.

## 자동 타입 변환
구현 객체가 인터페이스 타입으로 변환되는 것은 **자동 타입 변환**에 해당한다. 자동 타입 변환은 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다.

``인터페이스 변수 = 구현객체;``

인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환할 수 있다. 자동 타입 변환을 이용하면 필드의 다형성과 매개 변수의 다형성을 구현할 수 있다. 필드와 매개 변수의 타입을 인터페이스로 선언하면 다양한 구현 객체를 대입해서 실행결과를 다양하게 만들 수 있다.

## 매개 변수의 다형성
자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 많이 발생한다. 매개값을 다양화하기 위해서 상속에서는 매개 변수를 부모 타입으로 선언하고 호출할 때에는 자식 객체를 대입한다.

매개 변수를 인터페이스 타입으로 선언하고 호출할 때에는 구현 객체를 대입했을 때, 객체가 매개값으로 사용되면 자동 타입 변환이 일어난다. 매개 변수의 타입의 인터페이스일 경우 어떠한 구현 객체로 매개값으로 사용할 수 있고, 어떤 구현 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다. 이것이 인터페이스 **매개 변수의 다형성**이다.

## 강제 타입 변환
구현 객체가 인터페이스 타입으로 자동 타입 변환하면, 인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항이 따른다. 하지만 경우에 따라서는 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우도 발생한다. 이 때 **강제 타입 변환**을 해서 다시 구현 클래스 타입으로 변환한 다음, 구현 클래스의 필드와 메소드를 사용할 수 있다.

``구현클래스 변수 = (구현클래스) 인터페이스변수;``

## 객체 타입 확인
강제 타입 변환은 구현 객체가 인터페이스 타입으로 변환되어 있는 상태에서 가능하다. 그러나 어떤 구현 객체가 변환되어 있는지 알 수 없는 상태에서 무작정 강제 타입 변환할 경우 ClassCastException이 발생할 수도 있다.

A 객체가 인터페이스로 변환되어 있을 경우, B 타입으로 강제 타입 변환하면 구현 클래스 타입이 다르므로 ClassCastException이 발생한다. 메소드의 매개 변수가 인터페이스로 선언된 경우, 메소드를 호출할 때 다양한 구현 객체들을 매개값으로 지정할 수 있다(매개 변수의 다형성). 어떤 구현 객체가 지정될 지 모르는 상황에서 매개값을 B 타입으로 강제 타입 변환하면 똑같이 ClassCastException이 발생할 수 있다.

어떤 구현 객체가 인터페이스 타입으로 확인하는 법은 instanceof 연산자를 사용하면 된다. 인터페이스 타입으로 자동 타입 변환된 매개값을 다시 구현 클래스 타입으로 강제 타입 변환해야 한다면 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야 한다.

해당 부분에 대한 손코딩은 Driver.java, DriverEx.java 파일을 참고하면 된다.

## 핵심 포인트
**자동 타입 변환** : 구현 객체가 인터페이스 변수에 대입되는 것.

**다형성** : 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술이라는 개념상의 차이는 있지만, 둘 다 다형성을 구현하는 방법은 비슷하다. 모두 재정의와 타입 변환 기능을 제공하기 때문이다.

**강제 타입 변환** : 인터페이스에 대입된 구현 객체를 다시 원래 구현 클래스 타입으로 변환하는 것.

**instanceof** : 강제 타입 변환을 하기 전에 변환이 가능한지 조사할 때 사용한다. 상속에서는 자식 클래스 타입인지, 인터페이스에서는 구현 클래스 타입인지를 확인할 때 사용한다.

**인터페이스 상속** : 클래스는 다중 상속을 허용하지 않지만, 인터페이스는 다중 상속을 허용한다. 즉, extends 키워드 뒤에 상위 인터페이스가 올 수 있다.

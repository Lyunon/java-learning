# 인스턴스 멤버와 정적 멤버
**인스턴스 멤버**는 객체마다 가지고 있는 멤버를, **정적 멤버**는 클래스에 위치시키고 객체들이 공유하는 멤버를 말한다.

## 인스턴스 멤버와 this
인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.

인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.

### 인스턴스 멤버 선언
인스턴스 필드와 메소드를 선언하는 방법은 지금까지 공부한 내용과 별반 다르지 않다.

인스턴스 메소드는 객체에 소속된 멤버인데 객체 내부에 존재하지 않고 메소드 영역에 저장되고 공유되는 이유는 메소드는 코드 블록이므로 객체마다 동일한 코드 블록을 가지고 있을 필요가 없기 때문이다.

인스턴스를 붙인 이유는 메모리 블록 내부에 인스턴스 필드 등이 사용되는 경우가 있기 때문이다. 인스턴스 필드가 사용되면 메소드 역시 객체 없이는 실행할 수 없다.

### this
객체 외부에서 인스턴스 멤버에 접근하기 위해서 참조 변수를 사용하는 것과 마찬가지고 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.

해당 부분의 손코딩은 CarThis2API.java, CarThis2.java 파일을 참고하면 된다.

## 정적 멤버와 static
정적은 '고정된'이란 의미이다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.

이들을 각각 정적 필드, 정적 메소드라고 부른다.

### 정적 멤버 선언
클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트 연산자로 접근한다.

> 클래스.필드;
>
> 클래스.메소드( 매개값, ... );

정적 필드와 정적 메소드는 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근이 가능하다. 하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다.

해당 부분에 대한 손코딩은 CalStaticAPI.java, CalStatic.java 파일을 참고하면 된다.

### 정적 메소드 선언 시 주의할 점
객체가 없어도 실행된다는 특징 때문에 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체 자신의 참조인 this 키워드로 사용이 불가능하다.

정적 메소드에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

main() 메소드도 동일한 규칙이 적용된다. main() 메소드도 정적 메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main() 메소드에서 바로 사용할 수 없다.

해당 부분에 대한 손코딩은 CarStatic.java 파일을 참고하면 된다.

## 싱클톤
가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 **싱글톤**이라고 한다.

싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다. 생성자를 호출한 만큼 객체가 생성되기 때문이다. 생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다.

그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다. 참고로 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.

정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다. 대신 외부에서 호출할 수 있는 정적메소드인  getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

아래는 싱글톤을 만드는 코드다.

> public class 클래스 {
>
>     private static 클래스 singleton = new 클래스 (); //정적 필드
>
>     private 클래스() {} //생성자
>
>     static 클래스 getInstance() {
>
>         return singleton;
>
>     } //정적 메소드
>
> }

외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법이다. getInstance() 메소드는 단 하나의 객체만 리턴한다.

해당 부분에 대한 손코딩은 SingletonAPI.java, Singleton.java 파일을 참고하면 된다.

## final 필드와 상수
### final 필드
final은 '최종적'이란 뜻을 가지고 있다. final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것이다.

final 필드는 아래와 같이 선언한다.

```final 타입 필드 [= 초기값];```

final 필드의 초기값을 줄 수 있는 방법은 딱 두 가지밖에 없다. 첫 번째는 필드 선언 시에 주는 방법이고, 두 번째는 생성자에서 주는 방법이다.

단순 값이라면 필드 선언 시에 주는 것이 제일 간단하짐나 복잡한 초기화 코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정해야 한다.

생성자는 final 필드의 최종 초기화를 마쳐야 하는데, 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.

해당 부분에 대한 손코딩은 PersonAPI.java, Person.java 파일을 참고하면 된다.

### 상수
일반적으로 불변의 값을 상수(static final)라고 부른다. 불변의 값은 수학에서 사용되는 원주율 파이(π)나 지구의 무게 및 둘레 등이 해당된다. 이런 불변의 값을 저장하는 필드를 자바에서는 상수라고 한다.

final 필드를 상수라고 부르진 않는다. 이유는 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러 가지 값으로 초기화될 수 없기 때문이다.

final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다.

상수는 static이면서 final이러야 한다. static final 필드는 객체마다 존재하지 않고 클래스에만 존재한다. 그리고 한 번 초기값이 저장되면 변경할 수 없다.

```static final 타입 상수 = 초기값;```

상수 이름은 모두 대문자로 작성하는 것이 관례이다. 만약 서로 다른 언어가 혼합된 이름이라면 언더바로 단어들을 연결해준다.

해당 부분에 대한 손코딩은 EarthAPI.java, Earth.java 파일을 참고하면 된다.

## 핵심 포인트
**인스턴스 멤버** : 인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.

**this** : 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다. this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.

**정적 멤버** : 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다.

**static** : 정적 멤버를 선언할 때 사용하는 키워드이다.

**싱글톤** : 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 싱글톤이라고 한다.

**final 필드** : 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없는 필드를 말한다. final 필드는 final 키워드로 선언한다.

**상수** : 수학에서 사용되는 원주율 파이(π)나 지구의 무게 및 둘레 같은 불변의 값을 저장하는 필드를 자바에서는 상수라고 한다. 상수는 final static 키워드로 선언한다.

# 배열
배열은 같은 타입의 데이터를 연속된 공간에 나열하고, 각 데이터에 **인덱스**를 부여해놓은 자료구조이다.

배열은 아래와 같은 특징을 가진다.

> 배열은 같은 타입의 데이터만 저장할 수 있다. (만약 다른 타입의 값을 저장하려고 하면 타입 불일치 컴파일 에러 발생)
>
> 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다. (3개의 값을 저장하는 배열을 생성했다고 했을 때, 만약 5개의 값을 저장해야 하는 경우가 발생 시 길이 5의 새로운 배열을 생성하고 기존 배열 항목을 새 배열로 복사해야함)

## 배열 선언
배열을 사용하기 위해서는 우선 배열 변수를 선언해야 한다. 배열 변수 선언은 아래와 같이 두 가지 형식으로 작성할 수 있다.

> 타입[] 변수;
>
> 타입 변수[];

대괄호는 배열 변수를 선언하는 기호로 사용되는데, 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있다. 타입은 배열에 저장될 데이터의 타입을 말한다.

배열 변수는 참조 변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 되며, 만일 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화될 수 있다.

만약 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다. 배열을 생성하고 배열 변수가 참조하는 상태에서 값을 저장하거나 읽어야 한다.

## 배열 생성
배열 객체를 생성하려면 값 목록을 이용하거나 new 연산자를 이용하면 된다.

### 값 목록으로 배열 생성
값의 목록이 있다면 아래와 같이 간단하게 배열 객체를 생성할 수 있다.

```타입[] 변수 = { 값0, 값1, 값2, 값3, ...};```

중괄호는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴한다.

배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.

값의 목록으로 배열 객체를 주의할 점으로, 배열 변수를 이미 선언한 후에는 다른 실행문에서 중괄호를 사용한 배열 생성이 허용되지 않는다.

배열 변수를 미리 선언한 수 값 목록들이 나중에 결정되는 상황이라면 아래와 같이 new 연산자르 사용해서 값 목록을 지정해주면 된다. new 연산자 바로 뒤에는 배열 변수 선언에서 사용한 타입[]를 붙여주고 중괄호에는 값들을 나열한다.

```변수 = new 타입[] { 값0, 값1, 값2, 값3, ...};```

메소드의 매개값이 배열일 경우에도 마찬가지인데, 매개 변수로 int[] 배열이 선언된 add()메소드가 있을 경우, 값 목록으로 배열을 생성함과 동시에 add() 메소드의 매개값으로 사용하고자 할 때는 반드시 new 연산자를 사용해야 한다.

해당 부분의 손코딩은 ArrayCreateByValueList.java, ArrayCreateByValueList2.java 파일을 참고하면 된다.

### new 연산자로 배열 생성
값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 아래와 같이 배열 객체를 생성할 수 있다.

```타입[] 변수 = new 타입[길이];```

길이는 배열이 저장할 수 있는 값의 개수를 말한다. 이미 배열 변수가 선언된 경우에도 new 연산자로 배열을 생성할 수 있다.

아래는 타입별로 배열의 초기값이다.

> **기본 타입(정수)**
>
> byte[] : 0
>
> char[] : '\0000'
>
> short[] : 0
>
> int[] " 0
> 
> long[] : 0L
>
> **기본 타입(실수)**
>
> float[] : 0.0F
>
> double[] : 0.0
>
> **기본 타입(논리)**
>
> boolean[] : false
>
> **참조 타입**
>
> 클래스[] : null
>
> 인터페이스[] : null

배열이 생성되고 나서 특정 인덱스 위치에 새로운 값을 저장하려면 아래와 같이 대입 연산자를 사용하면 된다.

```변수[인덱스] = 값;```

해당 부분에 대한 손코딩은 ArrayCreateByNew.java 파일을 참고하면 된다.

## 배열 길이
배열의 길이란 배열에 저장할 수 있는 전체 항목의 개수를 말한다. 코드에서 배열의 길이를 얻으려면 아래와 같이 배열 객체의 length 필드를 읽는다. 참고로 필드는 객체 내부의 데이터를 말한다.

배열의 length 필드를 읽기 위해서는 배열 변수에 도트 연산자를 붙이고 length를 적어주면 된다.

```배열 변수.length;```

length 필드는 읽기 전용 필드이기 때문에 값을 바꿀 수가 없다.

배열의 length 필드는 for문을 사용해서 배열 전체를 루핑할 때 매우 유용하게 사용할 수 있다.

해당 부분에 대한 손코딩은 ArrayLength.java 파일을 참고하면 된다.

## 명령 라인 입력
```public static void main(String[] args) {...}```

명령 라인에서(명령 프롬프트)에서 위 코드를 java 명령어로 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고 main() 메소드를 호출할 때 매개값으로 전달한다.

만약 공백으로 구분된 문자열 목록을 주고 실행하면, 문자열 목록으로 구성된 String[] 배열이 먼저 생성되고 main() 메소드를 호출할 때 매개값으로 전달한다.

> [JDK 11 이후 버전] java -p . -m 모듈명/패키지.클래스 문자열0 문자열1 문자열2 ... 문자열n-1
>
> [JDK 8 이전 버전] java 패키지.클래스 문자열0 문자열1 문자열2 ... 문자열n-1

main() 메소드는 String[] args 매개 변수를 통해서 명령 라인에서 입력된 데이터의 수(배열의 길이)와 입력된 데이터(배열의 항목 값)를 알 수 있게 된다.

해당 부분에 대한 손코딩은 MainStringArrayArgument.java 파일을 참고하면 된다.

해당 파일을 실행할 때 매개값을 주지 않으면 길이 0인 String 배열이 매개값으로 전달된다.

해당 파일에서 매개값을 부여하였을 때, 문자열은 산술 연산을 할 수 없기 때문에 문자열들을 Integer.parseInt() 메소드를 이용해서 정수로 변환한다. 만약 정수로 변환할 수 없는 문자열이 주어졌을 경우 NumberFormatException이 발생한다.

## 다차원 배열
값들이 행과 열로서 구성된 배열을 2차원 배열이라고 하며, 2차원 배열은 수학의 행렬을 떠올리면 된다.(가로 인덱스와 세로 인덱스 사용)

자바는 2차원 배열을 중첩 배열 방식으로 구현한다.

배열의 생성 원리는 수학 행렬과 근본적으로 다르지만 사용 방식은 행렬과 동일하다. 자바는 1차원 배열이 서로 연결된 구조로 다차원 배열을 구현하기 때문에 수학 행렬 구조가 아닌 계단식 구조를 가질 수 있다.

주의할 점으로 배열의 정확한 길이를 알고 인덱스를 사용해야 한다. 그러지 않을 경우 ArrayIndexOutOFBoundsException이 발생된다.

만약 그룹화된 값 목록을 가지고 있다면 아래와 같이 중괄호 안에 다시 중괄호를 사용해서 값 목록으 나열한다.

```타입[][] 변수 = { {값1, 값2, ...}, {값1, 값2, ... }, ...};```

해당 부분에 대한 손코딩은 ArrayInArray.java 파일을 참고하면 된다.

## 객체를 참조하는 배열
기본 타입(byte, char, short, int, long, float, double, boolean) 배열은 각 항목에 직접 값을 갖고 있지만, 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 가지고 있다.

예시로 String은 클래스이므로 String[] 배열은 각 항목에 문자열이 아니라, String 객체의 번지를 가지고 있다. 즉, String[] 배열은 String 객체를 참조하게 된다.

String[] 배열의 항목도 결국 String 변수와 동일하게 취급되어야 한다. 예시로 String[] 배열 항목 간에 문자열을 비교하기 위해서는 == 연산자 대신 equals() 메소드를 사용해야 한다. ==는 객체의 번지를 비교하기 때문에 문자열을 비교하는 데는 사용할 수 없다.

해당 부분에 대한 손코딩은 ArrayReferenceObject.java 파일을 참고하면 된다.

## 배열 복사
배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 더 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 한다.

배열 간의 항목 값들을 복사하려면 for문을 사용하거나 System.arraycopy() 메소드를 사용한다.

System.arraycopy() 메소드를 호출하는 방법은 아래와 같다.

```System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);```

src 매개값은 원본 배열, srcPos는 원본 배열에서 복사할 항목의 시작 인덱스, dest 매개값은 새 배열, destPos는 새 배열에서 붙여넣을 시작 인덱스, length는 복사할 개수이다.

해당 부분의 손코딩은 ArrayCopyByFor.java, ArrayCopy.java 파일을 참고하면 된다.

참조 타입의 배열이 복사되면 복사되는 값이 객체의 번지이므로 새 배열의 항모은 이전 배열의 항모이 참조하는 객체와 동일하다.

## 향상된 for문
자바는 배열이나 컬레견을 좀 더 쉽게 처리하기 위해 향상된 for문을 제공한다. 향상된 for문은 반복 실행을 하기 위해 루프 카운터 변수와 증감식을 사용하지 않는다.

for문의 괄호에는 배열에서 꺼낸 항목을 젖아할 변수 선언과 콜론, 그리고 배열을 나란히 작성한다. 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.

형식은 아래와 같다.

> for ( 타입 변수 : 배열 ) {
>     실행문;
> }

해당 부분의 손코딩은 AdvancedFor.java 파일을 참고하면 된다.

## 배열 부분을 마치면서
향상된 for문이 조금 새로웠다. 다음은 열거 타입이다.

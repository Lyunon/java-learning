# 컬렉션 프레임워크
자바는 널리 알려져 있는 자료구조를 사용해서 객체들을 효율적으로 추가, 상제, 검색할 수 있도록 인터페이스와 구현 클래스를 java.util 패키지에서 제공한다. 이들을 총칭해서 **컬렉션 프레임워크**라고 부른다.

컬렉션은 객체의 저장을 뜻하고, **프레임워크**란 사용 방법을 정해놓은 라이브러리를 말한다. 실제로 컬렉션 프레임워크는 사용 방법을 정의한 인터페이스와 실제 객체를 저장하는 다양한 컬렉션 클래스(구현 클래스)를 제공한다.

컬렉션 프레임워크의 주요 인터페이스로는 List, Set, Map이 있다. 이 인터페이스들은 컬렉션 클래스를 사용하는 방법을 정의한 것이다.

## List 컬렉션
List 컬렉션은 배열과 비슷하게 객체를 인덱스로 관리한다. 배열과의 차이점은 저장 용량이 자동으로 증가하며, 객체를 저장할 때 자동 인덱스가 부여된다는 것이다. 그리고 추가, 삭제, 검색을 위한 다양한 메소드들이 제공된다.

List 컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다. 그렇기 때문에 동일한 객체를 중복 저장할 수 있는데, 이 경우 동일한 번지가 참조된다. null도 저장이 가능하며, 이 경우 해당 인덱스는 객체를 참조하지 않는다.

List 컬렉션에는 ArrayLsit, Vector, LinkedList 등이 있는데, 아래는 List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드이다. 인덱스로 객체를 관리하기 때문에 인덱스를 매개값으로 갖는 메소드가 많다.

> ## 객체 추가
>
> boolean add(E e) : 주어진 객체를 맨 끝에 추가한다.
>
> void add(int index, E element) : 주어진 인덱스에 객체를 추가한다.
>
> E set(int index, E element) : 주어진 인덱스에 저장된 객체를 주어진 객체로 바꾼다.
>
> ## 객체 검색
>
> boolean contains(Object o) : 주어진 객체가 저장되어 있는지 조사한다.
>
> E get(int index) : 주어진 인덱스에 저장된 객체를 리턴한다.
>
> boolean isEmpty() : 컬렉션이 비어 있는지 조사한다.
>
> int size() : 저장되어 있는 전체 객체 수를 리턴한다.
>
> ## 객체 삭제
>
> void clear() : 저장된 모든 객체를 삭제한다.
>
> E remove(int index) : 주어진 인덱스에 저장된 객체를 삭제한다.
>
> boolean remove(Object o) : 주어진 객체를 삭제한다.

메소드의 매개 변수 타입과 리턴 타입에 E라는 타입 파라미터가 있는데, 이것은 저장되는 객체의 타입을 List 컬렉션을 생성할 때 결정하라는 뜻이다.

List 컬렉션에 객체를 추가할 때에는 add() 메소드를 사용하고, 객체를 찾아올 때에는 get() 메소드를 사용한다. 그리고 객체 삭제는 remove() 메소드를 사용한다. 아래는 List 컬렉션에 String 객체를 추가, 삽입, 검색, 삭제하는 방법을 보여준다.

> List``<String>`` list = ...;
>
> list.add("홍길동"); //맨 끝에 객체 추가
>
> list.add(1, "신용권"); //지정된 인덱스에 객체 삽입
>
> String str = list.get(1); //인덱스로 객체 검색
>
> list.remove(0); //인덱스로 객체 삭제
>
> list.remove("신용권"); //객체 삭제

List<String>으로 list 변수를 선언했다. 이것은 List 컬렉션에 저장되는 객체를 String 타입으로 하겠다는 뜻이다. 따라서 E 타입 파라미터는 String 타입이 되는 것이다. 그래서 add() 메소드의 매개값은 문자열이 되고 get() 메소드의 리턴값은 문자열이 된다.

List 컬렉션에 저장된 모든 객체를 대상으로 하나씩 가져와 처리하고 싶다면 인덱스를 이용하는 방법과 향상된 for문을 이용하는 방법이 있다. 아래은 인덱스를 이용하는 방법이다. List 컬렉션의 size() 메소드는 현재 저장되어 있는 객체 수를 리턴한다.

> List``<String>`` list = ...;
>
> for(int i=0; i<list.size(); i++ { //저장된 총 객체 수만큼 루핑
>
> String str = list.get(i); //i 인덱스에 저장된 string 객체를 가져옴
>
> }

아래는 향상된 for문을 이용하는 방법이다. List 컬렉션에 저장된 객체 수를 반복하면서 객체를 하나씩 str 변수에 대입한다.

> for(String str : list) {
>
> }

### ArrayList
ArrayList는 List 인터페이스의 대표적인 구현 클래스이다. 아래는 ArrayList 객체를 생성하는 방법이다.

> List``<E>`` list = new ArrayList``<E>``();

ArrayList를 생성하기 위해서는 저장할 객체 타입을 E 타입 파라미터 자리에 표기하고 기본 생성자를 호출하면 된다. 예를 들어 String을 저장하는 ArrayList는 아래와 같이 생성할 수 있다.

> List``<String>`` list = new ArrayList``<String>``();
>
> List``<String>`` list = new ArrayList``<>``();

두 번째 코드와 같이 ArrayList의 E 타입 파라미터를 생략하면 왼쪽 List에 지정된 타입을 따라 간다. 따라서 위 두 코드는 동일하게 String을 저장하는 ArrayList 객체를 생성한다.

기본 생성자로 ArrayList 객체를 생성하면 내부에 10개의 객체를 저장할 수 있는 초기 용량을 가지게 된다. 저장되는 객체 수가 늘어나면 용량이 자동으로 증가한다.

ArrayList에 객체를 추가하면 0번 인덱스부터 차례대로 저장된다. ArrayList에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다. 마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다.

이런 동작 때문에 저장된 객체 수가 많고, 특정 인덱스에 객체를 추가하거나 제거하는 일이 빈번하다면 ArrayList보다는 LinkedList를 사용하는 것이 좋다. 하짐나 인덱스를 이용해서 찾거나 맨 마지막에 객체를 추가하는 경우에는 ArrayList가 더 좋은 성능을 발휘한다.

해당 부분에 대한 손코딩은 ArrayListEx.java 파일을 참고하면 된다.

### Vector
Vector는 ArrayList와 동일한 내부 구조르 가지고 있다. Vector를 생성하기 위해서는 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자로 호출하면 된다.

> List``<E>`` list = new Vector``<E>``();
>
> List``<E>`` list =new Vector``<>``();

ArrayList와 다른 점은 Vector는 동기화된 메소드로 구성되어 있기 대문에 멀티 스레드가 동시에 Vector의 메소드들을 실행할 수 없고, 하나의 스레드가 메소드를 실행을 완료해야만 다른 스레드가 메소드를 실행할 수 있다는 것이다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. 이것을 스레드에 안전하다고 표현한다.

해당 부분에 대한 손코딩은 VectorEx.java, Board.java 파일을 참고하면 된다.

# 상속
상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄여준다.

상속을 이용하면 부모 클래스의 수정으로 모든 자식 클래스들도 수정되는 효과를 가져오기 때문에 유지 보수 시간을 최소화할 수도 있다.

## 클래스 상속
자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정하고, 선택된 부모 클래스는 아래와 같이 extends 뒤에 기술한다.

> class 자식클래스 extends 부모클래스 {
>
> //필드
>
> //생성자
>
> //메소드
>
> }

자바에서 상속은 다음과 같은 특징을 가지고 있다.

1. 여러 개의 부모 클래스를 상속할 수 없다. 그러므로 extends 뒤에는 단 하나의 부모 클래스만 와야 한다.

2. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상ㅅ고 대상에서 제외된다.

해당 부분에 대한 손코딩은 CellPhone.java, DmbCellPhone.java, DmbPhone.java 파일을 참고하면 된다.

## 부모 생성자 호출
자식 객체를 생성하면, 부모 객체가 먼저 생성되고 그 다음에 자식 객체가 생성된다.

모든 객체는 클래스의 생성자를 호출해야만 생성된다. 부모 객체도 예외는 아니다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.

생성자가 명시적으로 선언되지 않았다면 컴파일러는 첫 줄에 super();를 추가하는데, 이는 부모의 기본 생성자를 호출한다.

만약 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 아래와 같이 작성하면 된다.

> 자식클래스( 매개변수선언, ...  {
>
>   super( 매개값, ... );
>
>   ...
>
> }

super(매개값, ...)는 매개값의 타입과 일치하는 부모 생성자를 호출한다. 만약 매개값의 타입과 일치하는 부모 생성자가 없을 경우 컴파일 에러가 발생한다.

부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 super(매개값, ...)를 명시적으로 호출해야 한다.

super(매개값, ...)는 반드시 자식 생성자 첫 줄에 위치해야 하며, 그렇지 않으면 컴파일 에러가 발생한다.

해당 부분에 대한 손코딩은 People.java 파일을 참고하면 된다.

해당 파일에서 People 클래스는 기본 생성자가 없고 name과 ssn을 매개값으로 받아 객체를 생성시키는 생성자만 있다. 그렇기 때문에 People을 상속하는 클래스는 생성자에서 super(name, ssn)으로 People 클래스의 생성자를 호출해야 한다.

해당 부분에 대한 손코딩은 Student.java 파일을 참고하면 된다.

Student 클래스의 생성자는 name, ssn, studentNo를 매개값으로 받아서 name과 ssn은 다시 부모 생성자를 호출하기 위해 매개값으로 넘겨준다.

5라인의 super(name,ssn)은 People 생성자인 People(String name, String ssn)을 호출하기 때문에, 이를 주석 처리하면 **"Implicit suepr constructor People() is undefined. Must explicitly invoke another constructor"** 컴파일 에러가 발생한다. 이는 부모의 기본 생성자가 없으니 다른 생성자를 명시적으로 호출하라느 의미이다. 

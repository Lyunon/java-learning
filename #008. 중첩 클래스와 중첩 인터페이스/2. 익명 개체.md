# 익명 객체
**익명 객체**는 이름이 없는 객체를 말하낟. 익명 객체를 만들려면 조건이 있다. 어떤 클래스를 상속하거나 인터페이스를 구현해야만 한다. 일반적인 경우에는 아래와 같이 명시적으로 클래스 이름을 주고 선언한다.

> **[상속]**
>
> class 클래스이름1 extends 부모클래스 { ... }
> 
> 부모클래스 변수 = new 클래스이름1();

> **[구현]**
>
> class 클래스이름2 implements 인터페이스 { ... }
>
> 인터페이스 변수 = new 클래스이름2();

이 경우 부모 클래스 변수는 클래스이름1의 객체를 참조하고, 인터페이스 변수는 클래스이름2의 객체를 참조한다. 그러나 익명 객체를 생성할 때에는 아래와 같이 클래스 이름이 없다.

> **[상속]**
>
> 부모클래스 변수 = new 부모클래스() { ... };

> **[구현]**
>
> 인터페이스 변수 = new 인터페이스 { ... };

이 경우 부모 클래스 변수는 이름이 없는 자식 객체를 참조하고, 인터페이스 변수는 이름이 없는 구현 객체를 참조하게 된다.

## 익명 자식 객체 생성
부모 타입의 필드 또는 변수를 선언하고 자식 객체를 초기값으로 대입하는 경우일 때, 우선 부모 클래스를 상속해서 자식 클래스를 선언하고 new 연산자를 이용해서 자식 객체를 생성한 후 부모 타입의 필드 도는 변수에 대입하는 것이 일반적이다.

자식 클래스를 명시적으로 선언하는 이유는 어디서건 이미 선언된 자식 클래스로 간단히 객체를 생성해서 사용할 수 있기 때문이다. 이것을 재사용성이 높다고 말한다.

그러나 자식 클래스가 재사용되지 않고, 오로지 특정 위치에서 사용할 경우라면 자식 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 된다. 이 경우, **익명 자식 객체**를 생성해서 사용하는 것이 좋은 방법이다. 익명 자식 객체를 생성하는 방법은 아래와 같다.

> 부모클래스 [필드|변수] = new 부모클래스(매개값, ...) {
>
> //필드
>
> //메소드
>
> };

``부모 클래스(매개값, ...) {...}``은 부모 클래스를 상속해서 중괄호와 같이 자식 클래스를 선언하라는 뜻이다. 그리고 new 연산자는 이렇게 선언된 자식 클래스를 객체로 생성한다.

``부모 클래스(매개값, ...)``은 부모 생성자를 호출하는 코드로, 매개값은 부모 생성자의 매개 변수에 맞게 입력하면 된다. 중괄호 내부에는 필드나 메소드를 선언하거나 부모 클래스의 메소드를 재정의(오버라이딩)하는 내용을 작성한다. 일반적으로 재정의 메소드가 많이 나온다. 일반 클래스와의 차이점은 생성자를 선언할 수 없다.

아래는 필드를 선언할 때 초기값으로 익명 자식 객체를 생성해서 대입하는 예이다.

> class A {
>
> Parent field = new Parent() {
>
> int childField;
>
> void childMethod() { }
>
> @Override
>
> void parentMethon() { }
>
> };
>
> }

아래는 메소드 내에서 로컬 변수를 선언할 때 초기값으로 익명 자식 객체를 생성해서 대입하는 예이다.

> class A {
>
> void method() {
>
> Parent localVar = new Parent() {
>
> int childField;
>
> void childMethod() { }
>
> @Override
>
> void parentMethod() {  }
>
> };
>
> }
>
> }

아래는 메소드의 매개 변수가 부모 타입일 경우 메소드를 호출하는 코드에서 익명 자식 객체를 생성해서 매개값으로 대입하는 예이다.

> class A {
>
> void method1(Parent parent) { }
>
> void method2() {
>
> method1(
>
> new Parent() {
>
> int childField;
>
> void chileMethod() { }
>
> @Override
>
> void parentMethod() { }
>
> }
>
> );
>
> }
>
> }

익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명 자식 객체 내부에서만 사용되고, 외부에서는 접근할 수 없다. 익명 자식 객체는 부모 타입 변수에 대입되므로 부모 타입에 선언된 것만 사용할 수 있기 때문이다.

해당 내용에 대한 손코딩은 Person.java, Anonymous.java, AnonymousEx.java 파일을 참고하면 된다.

## 익명 구현 객체 생성
인터페이스 타입의 필드 또는 변수를 선언하고, 구현 객체를 초기값으로 대입하는 경우, 우선 구현 클래스를 선언하고 new 연산자를 이용해서 구현 객체를 생성한 후 인터페이스 타입의 필드 또는 로컬 변수에 대입하는 것이 일반적이다.

구현 클래스를 명시적으로 선언하는 이유는 어디서건 이미 선언된 구현 클래스로 간단히 객체를 생성해서 사용할 수 있기 때문이다. 이것을 재사용성이 높다고 한다.

그러나 구현 클래스가 재사용되지 않고, 오로지 특정 위치에서 사용할 경우라면 구현 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 되는데, 이 경우 **익명 구현 객체**를 생성해서 사용하는 것이 좋은 방법이다. 익명 구현 객체를 생성하는 방법은 아래와 같다.

> 인터페이스 [필드|변수] = new 인터페이스() {
>
> //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
>
> //필드
>
> //메소드
>
> };

``인터페이스() { ... }``는 인터페이스를 구현해서 중괄호와 같이 클래스를 선언하라는 뜻이며 new 연산자는 이렇게 선언된 구현 클래스를 객체로 생성한다. 중괄호에는 인터페이스에 선언된 모든 추상 메소드의 실체 메소드를 작성(재정의)래야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

아래는 필드를 선언할 때 초기값으로 익명 구현 객체를 생성하는 예이다.

> class A {
>
> RemoteControl field = new RemoteControl() {
>
> @Override
>
> void turnOn() { }
>
> };
>
> }

아래는 메소드 내에서 로컬 변수를 선언할 때 초기값으로 익명 구현 객체를 생성해서 대입하는 예이다.

> void method() {
>
> RemoteControl localVar = new RemoteControl() {
>
> @Override
>
> void turnOn() { }
>
> };
>
> }

아래는 메소드의 매개 변수가 인터페이스 타입일 경우 메소드를 호출하는 코드에서 익명 구현 객체를 생성해서 매개값으로 대입하는 예이다.

> class A {
>
> void method1(RemoteControl rc) { }
>
> void method2() {
>
> method1(
>
> new RemoteControl() {
>
> @Override
>
> void turnOn() { }
>
> }
>
> );
>
> }
>
> }

해당 부분에 대한 손코딩은 RemoteControl.java, Anonymous2.java, Anonymous2Ex.java 파일을 참고하면 된다.

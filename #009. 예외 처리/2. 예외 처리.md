# 예외 처리
자바 컴파일러는 소스 파일을 컴파일할 때 일반 예외가 발생할 가능성이 있는 코드를 발견하면 컴파일 에러를 발생시켜 개발자가 강제적으로 **예외 처리 코드**를 작성하도록 요구한다. 그러나 실행 예외는 컴파일러가 체크해주지 않기 때문에 개발자의 경험을 바탕으로 예외 처리 코드를 작성해야 한다.

## 예외 처리 코드
**try-catch-finally 블록**은 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 해 준다. try-catch-finally 블록은 아래와 같이 작성한다.

> try {
>
> 예외 발생 가능 코드
>
> } catch(예외클래스 e) {
>
> 예외 처리
>
> } finally {
>
> 항상 실행;
>
> }

Class.forName() 메소드는 매개값으로 주어진 클래스가 존재하면 Class 객체를 리턴하지만, 존재하지 않으면 ClassNotFoundException을 발생시킨다.

ClassNotFoundException은 일반 예외이므로 컴파일러는 개발자에게 TryCatchFinallyEx.java 파일과 같이 예외 처리 코드를 작성하도록 요구한다.

해당 파일을 실행하면 java.lang.String2 클래스가 존재하지 않았기 때문에 예외 처리가 되었다.

ArrayIndexOutOFBoundsException이나 NumberFormatException과 같은 실행 예외는 컴파일러가 예외 처리 코드를 체크하지 않는다. 오로지 개발자의 경험에 의해 예외 처리를 TryCatchFinallyRuntimeExceptionEx.java 파일과 같이 작성해주어야 한다.

해당 파일을 실행시키면 ArrayIndexOutOfBoundsException이 발생하는데, 이는 실행 매개값을 주지 않았기 때문이다.

## 예외 종류에 따른 처리 코드
### 다중 catch
try 블록 내부는 다양한 예외가 발생할 수 있다. 이 경우 발생되는 예외별로 예외 처리 코드를 다르게 하기 위해 **다중 catch 블록**을 작성한다. catch 블록의 예외 클래스 타입은 try 블록에서 발생된 예외의 종류를 말하는데, try 블록에서 해당 타입의 예외가 발생하면 catch 블록을 실행하도록 되어 있다.

catch 블록이 여러 개라 할지라도 단 하나의 catch 블록만 실행된다. 그 이유는 try 블록에서 동시 다발적으로 예외가 발생하지 않고, 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch 블록으로 이동하기 때문이다.

해당 부분에 대한 손코딩은 CatchByExceptionKindEx.java 파일을 참고하면 된다.

### catch 순서
다중 catch 블록을 작성할 때 주의할 점은 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 한다는 것이다. try 블록에서 예외가 발생했을 때, 예외를 처리해줄 catch 블록은 위에서부터 차례대로 검색된다. 만약 상위 예외 클래스의 catch 블록이 위에 있다면, 하위 예외 클래스의 catch 블록은 실행되지 않는다. 왜냐하면 하위 예외는 상위 예외를 상속했기 때문에 상위 예외 타입도 되기 때문이다.
